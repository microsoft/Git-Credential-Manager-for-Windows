/**** Git Credential Manager for Windows ****
 *
 * Copyright (c) Microsoft Corporation
 * All rights reserved.
 *
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the """"Software""""), to deal
 * in the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
**/

using System;
using System.Runtime.InteropServices;
using System.Text;
using Microsoft.Win32.SafeHandles;

namespace Microsoft.Alm
{
    internal static class NativeMethods
    {
        public const string ConsoleInName = "CONIN$";
        public const string ConsoleOutName = "CONOUT$";

        private const string Advapi32 = "advapi32.dll";
        private const string CredUi32 = "credui.dll";
        private const string Kernel32 = "kernel32.dll";

        [Flags]
        public enum ConsoleMode : uint
        {
            /// <summary>
            /// CTRL+C is processed by the system and is not placed in the input buffer. If the input
            /// buffer is being read by
            /// <see cref="ReadConsole(SafeFileHandle, StringBuilder, uint, out uint, IntPtr)"/>,
            /// other control keys are processed by the system and are not returned in the
            /// ReadConsole buffer. If the <see cref="LineInput"/> mode is also enabled, backspace,
            /// carriage return, and line feed characters are handled by the system.
            /// </summary>
            ProcessedInput = 0x0001,
            /// <summary>
            /// The <see cref="ReadConsole(SafeFileHandle, StringBuilder, uint, out uint, IntPtr)"/>
            /// function returns only when a carriage return character is read. If this mode is
            /// disabled, the functions return when one or more characters are available.
            /// </summary>
            LineInput = 0x0002,
            /// <summary>
            /// Characters read by the
            /// <see cref="ReadConsole(SafeFileHandle, StringBuilder, uint, out uint, IntPtr)"/>
            /// function are written to the active screen buffer as they are read. This mode can be
            /// used only if the <see cref="LineInput"/> mode is also enabled.
            /// </summary>
            EchoInput = 0x0004,
            /// <summary>
            /// User interactions that change the size of the console screen buffer are reported in
            /// the console's input buffer. Information about these events can be read from the input
            /// buffer by applications using the ReadConsoleInput function, but not by those using <see cref="ReadConsole(SafeFileHandle, StringBuilder, uint, out uint, IntPtr)"/>.
            /// </summary>
            WindowInput = 0x0008,
            /// <summary>
            /// If the mouse pointer is within the borders of the console window and the window has
            /// the keyboard focus, mouse events generated by mouse movement and button presses are
            /// placed in the input buffer. These events are discarded by
            /// <see cref="ReadConsole(SafeFileHandle, StringBuilder, uint, out uint, IntPtr)"/>,
            /// even when this mode is enabled.
            /// </summary>
            MouseInput = 0x0010,
            /// <summary>
            /// When enabled, text entered in a console window will be inserted at the current cursor
            /// location and all text following that location will not be overwritten. When disabled,
            /// all following text will be overwritten.
            /// </summary>
            InsertMode = 0x0020,
            /// <summary>
            /// This flag enables the user to use the mouse to select and edit text.
            /// </summary>
            QuickEdit = 0x0040,

            /// <summary>
            /// Characters written by the
            /// <see cref="WriteConsole(SafeHandle, StringBuilder, uint, out uint, IntPtr)"/>
            /// function or echoed by the ReadFile or ReadConsole function are parsed for ASCII
            /// control sequences, and the correct action is performed. Backspace, tab, bell,
            /// carriage return, and line feed characters are processed.
            /// </summary>
            ProcessedOuput = 0x0001,
            /// <summary>
            /// When writing with
            /// <see cref="WriteConsole(SafeHandle, StringBuilder, uint, out uint, IntPtr)"/> or
            /// echoing with ReadFile or ReadConsole, the cursor moves to the beginning of the next
            /// row when it reaches the end of the current row. This causes the rows displayed in the
            /// console window to scroll up automatically when the cursor advances beyond the last
            /// row in the window. It also causes the contents of the console screen buffer to scroll
            /// up (discarding the top row of the console screen buffer) when the cursor advances
            /// beyond the last row in the console screen buffer. If this mode is disabled, the last
            /// character in the row is overwritten with any subsequent characters.
            /// </summary>
            WrapAtEolOutput = 0x0002,
        }

        [Flags]
        public enum FileAccess : uint
        {
            GenericRead = 0x80000000,
            GenericWrite = 0x40000000,
            GenericExecute = 0x20000000,
            GenericAll = 0x10000000,
        }

        [Flags]
        public enum FileAttributes : uint
        {
            /// <summary>
            /// The file is read only. Applications can read the file, but cannot write to or delete it.
            /// </summary>
            Readonly = 0x00000001,
            /// <summary>
            /// The file is hidden. Do not include it in an ordinary directory listing.
            /// </summary>
            Hidden = 0x00000002,
            /// <summary>
            /// The file is part of or used exclusively by an operating system.
            /// </summary>
            System = 0x00000004,
            Directory = 0x00000010,
            /// <summary>
            /// The file should be archived. Applications use this attribute to mark files for backup
            /// or removal.
            /// </summary>
            Archive = 0x00000020,
            Device = 0x00000040,
            /// <summary>
            /// The file does not have other attributes set. This attribute is valid only if used alone.
            /// </summary>
            Normal = 0x00000080,
            /// <summary>
            /// The file is being used for temporary storage.
            /// </summary>
            Temporary = 0x00000100,
            SparseFile = 0x00000200,
            ReparsePoint = 0x00000400,
            Compressed = 0x00000800,
            /// <summary>
            /// The data of a file is not immediately available. This attribute indicates that file
            /// data is physically moved to offline storage. This attribute is used by Remote
            /// Storage, the hierarchical storage management software. Applications should not
            /// arbitrarily change this attribute.
            /// </summary>
            Offline = 0x00001000,
            NotContentIndexed = 0x00002000,
            /// <summary>
            /// <para>
            /// The file or directory is encrypted. For a file, this means that all data in the file
            /// is encrypted. For a directory, this means that encryption is the default for newly
            /// created files and subdirectories.
            /// </para>
            /// <para>This flag has no effect if <see cref="Archive"/> is also specified.</para>
            /// <para>
            /// This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.
            /// </para>
            /// </summary>
            Encrypted = 0x00004000,
            FirstPipeInstance = 0x00080000,
            /// <summary>
            /// The file data is requested, but it should continue to be located in remote storage.
            /// It should not be transported back to local storage. This flag is for use by remote
            /// storage systems.
            /// </summary>
            OpenNoRecall = 0x00100000,
            /// <summary>
            /// <para>
            /// Normal reparse point processing will not occur;
            /// <see cref="CreateFile(string, FileAccess, FileShare, IntPtr, FileCreationDisposition, FileAttributes, IntPtr)"/>
            /// will attempt to open the reparse point. When a file is opened, a file handle is
            /// returned, whether or not the filter that controls the reparse point is operational.
            /// </para>
            /// <para>
            /// This flag cannot be used with the <see cref="FileCreationDisposition.CreateAlways"/> flag.
            /// </para>
            /// <para>If the file is not a reparse point, then this flag is ignored.</para>
            /// </summary>
            OpenReparsePoint = 0x00200000,
            /// <summary>
            /// The file or device is being opened with session awareness. If this flag is not
            /// specified, then per-session devices (such as a redirected USB device) cannot be
            /// opened by processes running in session 0. This flag has no effect for callers not in
            /// session 0. This flag is supported only on server editions of Windows.
            /// </summary>
            SessionAware = 0x00800000,
            /// <summary>
            /// Access will occur according to POSIX rules. This includes allowing multiple files
            /// with names, differing only in case, for file systems that support that naming. Use
            /// care when using this option, because files created with this flag may not be
            /// accessible by applications that are written for MS-DOS or 16-bit Windows.
            /// </summary>
            PosixSemantics = 0x01000000,
            /// <summary>
            /// <para>
            /// The file is being opened or created for a backup or restore operation. The system
            /// ensures that the calling process overrides file security checks when the process has
            /// SE_BACKUP_NAME and SE_RESTORE_NAME privileges.
            /// </para>
            /// <para>
            /// You must set this flag to obtain a handle to a directory. A directory handle can be
            /// passed to some functions instead of a file handle.
            /// </para>
            /// </summary>
            BackupSemantics = 0x02000000,
            /// <summary>
            /// <para>
            /// The file is to be deleted immediately after all of its handles are closed, which
            /// includes the specified handle and any other open or duplicated handles.
            /// </para>
            /// <para>
            /// If there are existing open handles to a file, the call fails unless they were all
            /// opened with the <see cref="FileShare.Delete"/> share mode.
            /// </para>
            /// <para>
            /// Subsequent open requests for the file fail, unless the <see cref="FileShare.Delete"/>
            /// share mode is specified.
            /// </para>
            /// </summary>
            DeleteOnClose = 0x04000000,
            /// <summary>
            /// <para>
            /// Access is intended to be sequential from beginning to end. The system can use this as
            /// a hint to optimize file caching.
            /// </para>
            /// <para>
            /// This flag should not be used if read-behind (that is, reverse scans) will be used.
            /// </para>
            /// <para>
            /// This flag has no effect if the file system does not support cached I/O and <see cref="NoBuffering"/>.
            /// </para>
            /// </summary>
            SequentialScan = 0x08000000,
            /// <summary>
            /// <para>
            /// Access is intended to be random. The system can use this as a hint to optimize file caching.
            /// </para>
            /// <para>
            /// This flag has no effect if the file system does not support cached I/O and <see cref="NoBuffering"/>.
            /// </para>
            /// </summary>
            RandomAccess = 0x10000000,
            /// <summary>
            /// <para>
            /// The file or device is being opened with no system caching for data reads and writes.
            /// This flag does not affect hard disk caching or memory mapped files.
            /// </para>
            /// <para>
            /// There are strict requirements for successfully working with files opened with
            /// <see cref="CreateFile(string, FileAccess, FileShare, IntPtr, FileCreationDisposition, FileAttributes, IntPtr)"/>
            /// using the <see cref="NoBuffering"/> flag.
            /// </para>
            /// </summary>
            NoBuffering = 0x20000000,
            /// <summary>
            /// <para>The file or device is being opened or created for asynchronous I/O.</para>
            /// <para>
            /// When subsequent I/O operations are completed on this handle, the event specified in
            /// the OVERLAPPED structure will be set to the signaled state.
            /// </para>
            /// <para>
            /// If this flag is specified, the file can be used for simultaneous read and write operations.
            /// </para>
            /// <para>
            /// If this flag is not specified, then I/O operations are serialized, even if the calls
            /// to the read and write functions specify an OVERLAPPED structure.
            /// </para>
            /// </summary>
            Overlapped = 0x40000000,
            /// <summary>
            /// Write operations will not go through any intermediate cache, they will go directly to disk.
            /// </summary>
            WriteThrough = 0x80000000,
        }

        public enum FileCreationDisposition : uint
        {
            /// <summary>
            /// <para>Creates a new file, only if it does not already exist.</para>
            /// <para>
            /// If the specified file exists, the function fails and the last-error code is set to <see cref="Win32Error.FileExists"/>.
            /// </para>
            /// <para>
            /// If the specified file does not exist and is a valid path to a writable location, a
            /// new file is created.
            /// </para>
            /// </summary>
            New = 1,
            /// <summary>
            /// <para>Creates a new file, always.</para>
            /// <para>
            /// If the specified file exists and is writable, the function overwrites the file, the
            /// function succeeds, and last-error code is set to <see cref="Win32Error.AlreadExists"/>.
            /// </para>
            /// <para>
            /// If the specified file does not exist and is a valid path, a new file is created, the
            /// function succeeds, and the last-error code is set to zero.
            /// </para>
            /// </summary>
            CreateAlways = 2,
            /// <summary>
            /// <para>Opens a file, always.</para>
            /// <para>
            /// If the specified file exists, the function succeeds and the last-error code is set to <see cref="Win32Error.AlreadExists"/>.
            /// </para>
            /// <para>
            /// If the specified file does not exist and is a valid path to a writable location, the
            /// function creates a file and the last-error code is set to zero.
            /// </para>
            /// </summary>
            OpenExisting = 3,
            /// <summary>
            /// <para>Opens a file or device, only if it exists.</para>
            /// <para>
            /// If the specified file or device does not exist, the function fails and the last-error
            /// code is set to <see cref="Win32Error.FileNotFound"/>.
            /// </para>
            /// </summary>
            OpenAlways = 4,
            /// <summary>
            /// <para>Opens a file and truncates it so that its size is zero bytes, only if it exists.</para>
            /// <para>
            /// If the specified file does not exist, the function fails and the last-error code is
            /// set to <see cref="Win32Error.FileNotFound"/>.
            /// </para>
            /// <para>The calling process must open the file with <see cref="FileAccess.GenericWrite"/>.</para>
            /// </summary>
            TruncateExisting = 5
        }

        [Flags]
        public enum FileShare : uint
        {
            /// <summary>
            /// Prevents other processes from opening a file or device if they request delete, read,
            /// or write access.
            /// </summary>
            None = 0x00000000,
            /// <summary>
            /// <para>Enables subsequent open operations on an object to request read access.</para>
            /// <para>Otherwise, other processes cannot open the object if they request read access.</para>
            /// <para>
            /// If this flag is not specified, but the object has been opened for read access, the
            /// function fails.
            /// </para>
            /// </summary>
            Read = 0x00000001,
            /// <summary>
            /// <para>Enables subsequent open operations on an object to request write access.</para>
            /// <para>Otherwise, other processes cannot open the object if they request write access.</para>
            /// <para>
            /// If this flag is not specified, but the object has been opened for write access, the
            /// function fails.
            /// </para>
            /// </summary>
            Write = 0x00000002,
            /// <summary>
            /// <para>Enables subsequent open operations on an object to request delete access.</para>
            /// <para>Otherwise, other processes cannot open the object if they request delete access.</para>
            /// <para>
            /// If this flag is not specified, but the object has been opened for delete access, the
            /// function fails.
            /// </para>
            /// </summary>
            Delete = 0x00000004
        }

        public enum FileType : uint
        {
            /// <summary>
            /// Either the type of the specified file is unknown, or the function failed.
            /// </summary>
            Unknown = 0x0000,
            /// <summary>
            /// The specified file is a disk file.
            /// </summary>
            Disk = 0x0001,
            /// <summary>
            /// The specified file is a character file, typically an LPT device or a console.
            /// </summary>
            Char = 0x0002,
            /// <summary>
            /// The specified file is a socket, a named pipe, or an anonymous pipe.
            /// </summary>
            Pipe = 0x0003,
            /// <summary>
            /// Unused.
            /// </summary>
            Remote = 0x8000,
        };

        public enum StandardHandleType : int
        {
            /// <summary>
            /// The standard input device. Initially, this is the console input buffer, CONIN$.
            /// </summary>
            Input = -10,
            /// <summary>
            /// The standard output device. Initially, this is the active console screen buffer, CONOUT$.
            /// </summary>
            Output = -11,
            /// <summary>
            /// The standard error device. Initially, this is the active console screen buffer, CONOUT$.
            /// </summary>
            Error = -12
        };

        [Flags]
        public enum CredentialPackFlags : uint
        {
            None = 0,
            ProtectedCredentials = 0x1,
            WowBuffer = 0x2,
            GenericCredentials = 0x4,
        }

        internal enum CredentialType : uint
        {
            /// <summary> <para>The `<see cref="Credential"/>` is a generic credential. The
            /// credential will not be used by any particular authentication package.</para>
            /// <para>The credential will be stored securely but has no other significant
            /// characteristics.<para> </summary>
            Generic = 0x01,
            /// <summary>
            /// <para>
            /// The ` <see cref="Credential"/>` is a password credential and is specific to
            /// Microsoft's authentication packages.
            /// </para>
            /// <para>
            /// The NTLM, Kerberos, and Negotiate authentication packages will automatically use this
            /// credential when connecting to the named target.
            /// </para>
            /// </summary>
            DomainPassword = 0x02,
            /// <summary>
            /// <para>
            /// The ` <see cref="Credential"/>` is a certificate credential and is specific to
            /// Microsoft's authentication packages.
            /// </para>
            /// <para>
            /// The Kerberos, Negotiate, and Schannel authentication packages automatically use this
            /// credential when connecting to the named target.
            /// </para>
            /// </summary>
            DomainCertificate = 0x03,
            /// <summary>
            /// <para>
            /// The ` <see cref="Credential"/>` is a password credential and is specific to
            /// authentication packages from Microsoft.
            /// </para>
            /// <para>
            /// The Passport authentication package will automatically use this credential when
            /// connecting to the named target.
            /// </para>
            /// </summary>
            [Obsolete("This value is no longer supported", true)]
            DomainVisiblePassword = 0x04,
            /// <summary>
            /// <para>
            /// The ` <see cref="Credential"/>` is a certificate credential that is a generic
            /// authentication package.
            /// </para>
            /// </summary>
            GenericCertificate = 0x05,
            /// <summary>
            /// <para>The ` <see cref="Credential"/>` is supported by extended Negotiate packages.</para>
            /// </summary>
            /// <remarks>
            /// Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP: This value
            /// is not supported.
            /// </remarks>
            DomainExtended = 0x06,
            /// <summary> <para>The maximum number of supported credential types.<para> </summary>
            /// <remarks> Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP:
            /// This value is not supported. </remarks>
            Maximum = 0x07,
            /// <summary>
            /// <para>
            /// The extended maximum number of supported credential types that now allow new
            /// applications to run on older operating systems.
            /// </para>
            /// </summary>
            /// <remarks>
            /// Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP: This value
            /// is not supported.
            /// </remarks>
            MaximumEx = Maximum + 1000
        }

        [Flags]
        public enum CredentialUiFlags : uint
        {
            None = 0,
            IncorrectPassword = 0x1,
            DoNoPersist = 0x2,
            EquestAdministrator = 0x4,
            ExcludeCertificates = 0x8,
            RequireCertificates = 0x10,
            ShowSaveCheckbox = 0x40,
            AlwaysShowUi = 0x80,
            RequireSmartCard = 0x100,
            PasswordOnlyOk = 0x200,
            ValidateUsername = 0x400,
            CompleteUsername = 0x800,
            Persist = 0x1000,
            ServerCredential = 0x4000,
            ExpectConfermatino = 0x20000,
            GenericCredentals = 0x40000,
            UsernameTargetCredentials = 0x80000,
            KeepUsername = 0x100000,
        }

        public enum CredentialUiResult : uint
        {
            Success = 0,
            Cancelled = 1223,
            NoSuchLogonSession = 1312,
            NotFound = 1168,
            InvalidAccountName = 1315,
            InsufficientBuffer = 122,
            InvalidParameter = 87,
            InvalidFlags = 1004,
        }

        [Flags]
        public enum CredentialUiWindowsFlags : uint
        {
            None = 0,
            /// <summary>
            /// The caller is requesting that the credential provider return the user name and
            /// password in plain text.
            /// </summary>
            Generic = 0x1,
            /// <summary>
            /// The Save check box is displayed in the dialog box.
            /// </summary>
            Checkbox = 0x2,
            /// <summary>
            /// Only credential providers that support the authentication package specified by the
            /// `authPackage` parameter should be enumerated.
            /// </summary>
            AuthPackageOnly = 0x10,
            /// <summary>
            /// <para>
            /// Only the credentials specified by the `inAuthBuffer` parameter for the authentication
            /// package specified by the `authPackage` parameter should be enumerated.
            /// </para>
            /// <para>
            /// If this flag is set, and the `inAuthBuffer` parameter is `null`, the function fails.
            /// </para>
            /// </summary>
            InCredOnly = 0x20,
            /// <summary>
            /// Credential providers should enumerate only administrators. This value is intended for
            /// User Account Control (UAC) purposes only. We recommend that external callers not set
            /// this flag.
            /// </summary>
            EnumerateAdmins = 0x100,
            /// <summary>
            /// Only the incoming credentials for the authentication package specified by the
            /// `authPackage` parameter should be enumerated.
            /// </summary>
            EnumerateCurrentUser = 0x200,
            /// <summary>
            /// The credential dialog box should be displayed on the secure desktop. This value
            /// cannot be combined with <see cref="Generic"/>.
            /// </summary>
            SecurePrompt = 0x1000,
            /// <summary>
            /// The credential dialog box is invoked by the SspiPromptForCredentials function, and
            /// the client is prompted before a prior handshake. If SSPIPFC_NO_CHECKBOX is passed in
            /// the `inAuthBuffer` parameter, then the credential provider should not display the
            /// check box.
            /// </summary>
            Preprompting = 0x2000,
            /// <summary>
            /// The credential provider should align the credential BLOB pointed to by the
            /// `outAuthBuffer` parameter to a 32-bit boundary, even if the provider is running on a
            /// 64-bit system.
            /// </summary>
            Pack32Wow = 0x10000000,
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public unsafe struct CredentialUiInfo
        {
            [MarshalAs(UnmanagedType.U4)]
            public int Size;
            [MarshalAs(UnmanagedType.SysInt)]
            public IntPtr Parent;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string MessageText;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string CaptionText;
            [MarshalAs(UnmanagedType.SysInt)]
            public IntPtr BannerArt;
        }

        /// <summary> Creates and displays a configurable dialog box that accepts credentials
        /// information from a user. </summary> <param name="credUiInfo">A pointer to a <see
        /// cref="CredentialUiInfo"/> structure that contains information for customizing the
        /// appearance of the dialog box</param> <param name="targetName">A pointer to a
        /// null-terminated string that contains the name of the target for the credentials,
        /// typically a server name. For Distributed File System (DFS) connections, this string is of
        /// the form ServerName\ShareName. This parameter is used to identify target information when
        /// storing and retrieving credentials.</param> <param name="reserved">This parameter is
        /// reserved for future use. It must be NUL</param> <param name="authError">Specifies why the
        /// credential dialog box is needed. A caller can pass this Windows error parameter, returned
        /// by another authentication call, to allow the dialog box to accommodate certain errors.
        /// For example, if the password expired status code is passed, the dialog box could prompt
        /// the user to change the password on the account.</param> <param name="username"> <para>A
        /// pointer to a null-terminated string that contains the user name for the credentials. If a
        /// nonzero-length string is passed, the <paramref name="username"/> option of the dialog box
        /// is prefilled with the string.</param> <param name="usernameMaxLen">The maximum number of
        /// characters that can be copied to <paramref name="username"/> including the terminating
        /// null character.</param> <param name="password"> <para>A pointer to a null-terminated
        /// string that contains the password for the credentials. If a nonzero-length string is
        /// specified for <paramref name="password"/>, the password option of the dialog box will be
        /// prefilled with the string.</para> </param> <param name="passwordMaxLen">he maximum number
        /// of characters that can be copied to <paramref name="password"/> including the terminating
        /// null character.</param> <param name="saveCredentials">A pointer to a <langword
        /// name="bool"/> that specifies the initial state of the Save check box and receives the
        /// state of the Save check box after the user has responded to the dialog box. If this value
        /// is not NULL and <see cref="CredUIPromptForCredentials"/> returns <see
        /// cref="CredentialUiResult.Success"/>, then <paramref name="save"/> returns the state of
        /// the Save check box when the user chose OK in the dialog box.</param> <param
        /// name="flags">Specifies special behavior for this function</param> <returns><see cref="CredentialUiResult"/></returns>
        [DllImport(CredUi32, CharSet = CharSet.Unicode, EntryPoint = "CredUIPromptForCredentialsW", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.U4)]
        public static extern CredentialUiResult CredUIPromptForCredentials(
            [In, MarshalAs(UnmanagedType.Struct)] ref CredentialUiInfo credUiInfo,
            [In, MarshalAs(UnmanagedType.LPWStr)] string targetName,
            [In, MarshalAs(UnmanagedType.SysInt)] IntPtr reserved,
            [In, MarshalAs(UnmanagedType.U4)] uint authError,
            [In, MarshalAs(UnmanagedType.LPWStr)] StringBuilder username,
            [In, MarshalAs(UnmanagedType.I4)] int usernameMaxLen,
            [In, MarshalAs(UnmanagedType.LPWStr)] StringBuilder password,
            [In, MarshalAs(UnmanagedType.I4)] int passwordMaxLen,
            [In, MarshalAs(UnmanagedType.Bool)] ref bool saveCredentials,
            [In, MarshalAs(UnmanagedType.U4)] CredentialUiFlags flags);

        /// <summary>
        /// Creates and displays a configurable dialog box that allows users to supply credential
        /// information by using any credential provider installed on the local computer.
        /// </summary>
        /// <param name="credInfo">
        /// <para>
        /// A pointer to a <see cref="CredentialUiInfo"/> structure that contains information for
        /// customizing the appearance of the dialog box that this function displays.
        /// </para>
        /// <para>
        /// If the hwndParent member of the <see cref="CredentialUiInfo"/> structure is not NULL,
        /// this function displays a modal dialog box centered on the parent window.
        /// </para>
        /// <para>
        /// If the hwndParent member of the <see cref="CredentialUiInfo"/> structure is NULL, the
        /// function displays a dialog box centered on the screen.
        /// </para>
        /// <para>
        /// This function ignores the <see cref="CredentialUiInfo.BannerArt"/> member of the
        /// <see cref="CredentialUiInfo"/> structure.
        /// </para>
        /// </param>
        /// <param name="authError">
        /// A Windows error code, defined in Winerror.h, that is displayed in the dialog box. If
        /// credentials previously collected were not valid, the caller uses this parameter to pass
        /// the error message from the API that collected the credentials (for example, Winlogon) to
        /// this function. The corresponding error message is formatted and displayed in the dialog
        /// box. Set the value of this parameter to zero to display no error message.
        /// </param>
        /// <param name="authPackage">
        /// <para>
        /// On input, the value of this parameter is used to specify the authentication package for
        /// which the credentials in the <paramref name="inAuthBuffer"/> buffer are serialized. If
        /// the value of <paramref name="inAuthBuffer"/> is `null` and the
        /// <see cref="CredentialUiWindowsFlags.AuthPackageOnly"/> flag is set in the
        /// <paramref name="flgs"/> parameter, only credential providers capable of serializing
        /// credentials for the specified authentication package are to be enumerated.
        /// </para>
        /// <para>
        /// To get the appropriate value to use for this parameter on input, call the
        /// `LsaLookupAuthenticationPackage` function and use the value of the
        /// <paramref name="authPackage"/> parameter of that function.
        /// </para>
        /// <para>
        /// On output, this parameter specifies the authentication package for which the credentials
        /// in the <paramref name="outAuthBuffer"/> buffer are serialized.
        /// </para>
        /// </param>
        /// <param name="inAuthBuffer">
        /// A pointer to a credential BLOB that is used to populate the credential fields in the
        /// dialog box. Set the value of this parameter to NULL to leave the credential fields empty.
        /// </param>
        /// <param name="inAuthBufferSize">The size, in bytes, of the pvInAuthBuffer buffer.</param>
        /// <param name="outAuthBuffer">
        /// <para>
        /// The address of a pointer that, on output, specifies the credential BLOB. For Kerberos,
        /// NTLM, or Negotiate credentials, call the CredUnPackAuthenticationBuffer function to
        /// convert this BLOB to string representations of the credentials.
        /// </para>
        /// <para>
        /// When you have finished using the credential BLOB, clear it from memory by calling the
        /// SecureZeroMemory function, and free it by calling the CoTaskMemFree function.
        /// </para>
        /// </param>
        /// <param name="outAuthBufferSize">The size, in bytes, of the ppvOutAuthBuffer buffer.</param>
        /// <param name="saveCredentials">
        /// <para>
        /// A pointer to a `bool` value that, on input, specifies whether the Save check box is
        /// selected in the dialog box that this function displays. On output, the value of this
        /// parameter specifies whether the Save check box was selected when the user clicks the
        /// Submit button in the dialog box. Set this parameter to `null` to ignore the Save check box.
        /// </para>
        /// <para>
        /// This parameter is ignored if the CREDUIWIN_CHECKBOX flag is not set in the dwFlags parameter.
        /// </para>
        /// </param>
        /// <param name="flags">A value that specifies behavior for this function.</param>
        /// <returns><see cref="Win32Error"/> code value on failure; otherwise <see cref="Win32Error.Success"/>.</returns>
        [DllImport(CredUi32, CharSet = CharSet.Unicode, EntryPoint = "CredUIPromptForWindowsCredentialsW", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.I4)]
        public static extern int CredUIPromptForWindowsCredentials(
            [In, MarshalAs(UnmanagedType.Struct)] ref CredentialUiInfo credInfo,
            [In, MarshalAs(UnmanagedType.U4)] uint authError,
            [In, Out, MarshalAs(UnmanagedType.U4)] ref CredentialPackFlags authPackage,
            [In, MarshalAs(UnmanagedType.SysInt)] IntPtr inAuthBuffer,
            [In, MarshalAs(UnmanagedType.U4)] uint inAuthBufferSize,
            [Out, MarshalAs(UnmanagedType.SysInt)] out IntPtr outAuthBuffer,
            [Out, MarshalAs(UnmanagedType.U4)] out uint outAuthBufferSize,
            [In, MarshalAs(UnmanagedType.Bool)] ref bool saveCredentials,
            [In, MarshalAs(UnmanagedType.U4)] CredentialUiWindowsFlags flags);

        /// <summary>
        /// Converts a string user name and password into an authentication buffer.
        /// </summary>
        /// <param name="flags">
        /// Specifies how the credential should be packed. This can be a combination of the following flags.
        /// </param>
        /// <param name="username">
        /// A pointer to a null-terminated string that specifies the user name to be converted.
        /// </param>
        /// <param name="password">
        /// A pointer to a null-terminated string that specifies the password to be converted.
        /// </param>
        /// <param name="packedCredentials">
        /// A pointer to an array of bytes that, on output, receives the packed authentication
        /// buffer. This parameter can be `null` to receive the required buffer size in the
        /// <paramref name="packedCredentialsSize"/> parameter.
        /// </param>
        /// <param name="packedCredentialsSize">
        /// A pointer to a DWORD value that specifies the size, in bytes, of the
        /// <paramref name="packedCredentials"/> buffer. On output, if the buffer is not of
        /// sufficient size, specifies the required size, in bytes, of the
        /// <paramref name="packedCredentials"/> buffer.
        /// </param>
        /// <returns>True if success; otherwise false.</returns>
        [DllImport(CredUi32, CharSet = CharSet.Unicode, EntryPoint = "CredPackAuthenticationBufferW", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool CredPackAuthenticationBuffer(
            [In, MarshalAs(UnmanagedType.U4)] CredentialPackFlags flags,
            [In, MarshalAs(UnmanagedType.LPWStr)] string username,
            [In, MarshalAs(UnmanagedType.LPWStr)] string password,
            [In, MarshalAs(UnmanagedType.SysInt)] IntPtr packedCredentials,
            [In, MarshalAs(UnmanagedType.I4)] ref int packedCredentialsSize);

        /// <summary>
        /// Converts an authentication buffer returned by a call to the
        /// <see cref="CredUIPromptForWindowsCredentials"/> function into a string user name and password.
        /// </summary>
        /// <param name="flags">
        /// <para>
        /// Setting the value of this parameter to `CRED_PACK_PROTECTED_CREDENTIALS` specifies that
        /// the function attempts to decrypt the credentials in the authentication buffer. If the
        /// credential cannot be decrypted, the function returns `false`, and a call to the
        /// GetLastError function will return the value <see cref="Win32Error.NotCapable"/>.
        /// </para>
        /// <para>How the decryption is done depends on the format of the authentication buffer.</para>
        /// <para>
        /// If the authentication buffer is a `SEC_WINNT_AUTH_IDENTITY_EX2` structure, the function
        /// can decrypt the buffer if it is encrypted by using `SspiEncryptAuthIdentityEx` with the
        /// `SEC_WINNT_AUTH_IDENTITY_ENCRYPT_SAME_LOGON` option.
        /// </para>
        /// <para>
        /// If the authentication buffer is one of the marshaled `KERB_*_LOGON` structures, the
        /// function decrypts the password before returning it in the <paramref name="password"/> buffer.
        /// </para>
        /// </param>
        /// <param name="authBuffer">A pointer to the authentication buffer to be converted.</param>
        /// <param name="authBufferSize">The size, in bytes, of the pAuthBuffer buffer.</param>
        /// <param name="username">
        /// A pointer to a null-terminated string that receives the user name.
        /// </param>
        /// <param name="maxUsernameLen">
        /// A pointer to a DWORD value that specifies the size, in characters, of the
        /// <paramref name="username"/> buffer. On output, if the buffer is not of sufficient size,
        /// specifies the required size, in characters, of the <paramref name="username"/> buffer.
        /// The size includes terminating `null` character.
        /// </param>
        /// <param name="domainName">
        /// A pointer to a null-terminated string that receives the name of the user's domain.
        /// </param>
        /// <param name="maxDomainNameLen">
        /// pointer to a DWORD value that specifies the size, in characters, of the
        /// <paramref name="domainName"/> buffer. On output, if the buffer is not of sufficient size,
        /// specifies the required size, in characters, of the <paramref name="domainName"/> buffer.
        /// The size includes the terminating `null` character. The required size can be zero if
        /// there is no domain name.
        /// </param>
        /// <param name="password">A pointer to a null-terminated string that receives the password.</param>
        /// <param name="maxPasswordLen">
        /// A pointer to a DWORD value that specifies the size, in characters, of the
        /// <paramref name="password"/> buffer. On output, if the buffer is not of sufficient size,
        /// specifies the required size, in characters, of the <paramref name="password"/> buffer.
        /// The size includes the terminating `null` character.
        /// </param>
        /// <returns>True if successful; otherwise false.</returns>
        [DllImport(CredUi32, CharSet = CharSet.Unicode, EntryPoint = "CredUnPackAuthenticationBufferW", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool CredUnPackAuthenticationBuffer(
            [In, MarshalAs(UnmanagedType.U4)] CredentialPackFlags flags,
            [In, MarshalAs(UnmanagedType.SysInt)] IntPtr authBuffer,
            [In, MarshalAs(UnmanagedType.U4)] uint authBufferSize,
            [In, Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder username,
            [In, Out, MarshalAs(UnmanagedType.I4)] ref int maxUsernameLen,
            [In, Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder domainName,
            [In, Out, MarshalAs(UnmanagedType.I4)] ref int maxDomainNameLen,
            [In, Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder password,
            [In, Out, MarshalAs(UnmanagedType.I4)] ref int maxPasswordLen);

        /// <summary>
        /// Creates or opens a file or I/O device. The most commonly used I/O devices are as
        /// follows: file, file stream, directory, physical disk, volume, console buffer, tape drive,
        /// communications resource, mailslot, and pipe. The function returns a handle that can be
        /// used to access the file or device for various types of I/O depending on the file or
        /// device and the flags and attributes specified.
        /// </summary>
        /// <param name="fileName">
        /// <para>
        /// The name of the file or device to be created or opened. You may use either forward
        /// slashes (/) or backslashes (\) in this name.
        /// </para>
        /// <para>
        /// In the ANSI version of this function, the name is limited to MAX_PATH characters. To
        /// extend this limit to 32,767 wide characters, call the Unicode version of the function and
        /// prepend "\\?\" to the path.
        /// </para>
        /// </param>
        /// <param name="desiredAccess">
        /// <para>
        /// The requested access to the file or device, which can be summarized as read, write, both
        /// or neither zero).
        /// </para>
        /// <para>
        /// f this parameter is zero, the application can query certain metadata such as file,
        /// directory, or device attributes without accessing that file or device, even if
        /// <see cref="FileAccess.GenericRead"/> access would have been denied.
        /// </para>
        /// <para>
        /// You cannot request an access mode that conflicts with the sharing mode that is specified
        /// by the <paramref name="sharedMode"/> parameter in an open request that already has an
        /// open handle.
        /// </para>
        /// </param>
        /// <param name="shareMode">
        /// <para>
        /// The requested sharing mode of the file or device, which can be read, write, both, delete,
        /// all of these, or none (refer to the following table). Access requests to attributes or
        /// extended attributes are not affected by this flag.
        /// </para>
        /// <para>
        /// If this parameter is zero and CreateFile succeeds, the file or device cannot be shared
        /// and cannot be opened again until the handle to the file or device is closed.
        /// </para>
        /// <para>
        /// You cannot request a sharing mode that conflicts with the access mode that is specified
        /// in an existing request that has an open handle. CreateFile would fail and the
        /// <see cref="Marshal.GetLastWin32Error"/> function would return <see cref="Win32Error.SharingViloation"/>.
        /// </para>
        /// <para>
        /// To enable a process to share a file or device while another process has the file or
        /// device open, use a compatible combination of one or more of the following values.
        /// </para>
        /// </param>
        /// <param name="securityAttributes">This parameter should be <see cref="IntPtr.Zero"/>.</param>
        /// <param name="creationDisposition">
        /// <para>An action to take on a file or device that exists or does not exist.</para>
        /// <para>For devices other than files, this parameter is usually set to <see cref="FileCreationDisposition.OpenExisting"/>.</para>
        /// </param>
        /// <param name="flagsAndAttributes">
        /// <para>
        /// The file or device attributes and flags, <see cref="FileAttributes.Normal"/> being the
        /// most common default value for files.
        /// </para>
        /// <para>
        /// This parameter can include any combination of <see cref="FileAttributes"/>. All other
        /// file attributes override <see cref="FileAttributes.Normal"/>.
        /// </para>
        /// </param>
        /// <param name="templateFile">This parameter should be <see cref="IntPtr.Zero"/>.</param>
        /// <returns>A handle to the file created.</returns>
        [DllImport(Kernel32, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, EntryPoint = "CreateFileW", SetLastError = true)]
        public static extern SafeFileHandle CreateFile(
            [In, MarshalAs(UnmanagedType.LPWStr)] string fileName,
            [In, MarshalAs(UnmanagedType.U4)] FileAccess desiredAccess,
            [In, MarshalAs(UnmanagedType.U4)] FileShare shareMode,
            [In, MarshalAs(UnmanagedType.SysInt)] IntPtr securityAttributes,
            [In, MarshalAs(UnmanagedType.U4)] FileCreationDisposition creationDisposition,
            [In, MarshalAs(UnmanagedType.U4)] FileAttributes flagsAndAttributes,
            [In, MarshalAs(UnmanagedType.SysInt)] IntPtr templateFile);

        /// <summary>
        /// Retrieves the current input mode of a console's input buffer or the current output mode
        /// of a console screen buffer.
        /// </summary>
        /// <param name="consoleHandle">
        /// A handle to the console input buffer or the console screen buffer. The handle must have
        /// the <see cref="FileAccess.GenericRead"/> access right.
        /// </param>
        /// <param name="consoleMode">
        /// <para>A pointer to a variable that receives the current mode of the specified buffer.</para>
        /// <para>
        /// If the <paramref name="consoleHandle"/> parameter is an input handle, the mode can be one
        /// or more of the following values. When a console is created, all input modes except
        /// <see cref="ConsoleMode.WindowInput"/> are enabled by default.
        /// </para>
        /// <para>
        /// If the <paramref name="consoleHandle"/> parameter is a screen buffer handle, the mode can
        /// be one or more of the following values. When a screen buffer is created, both output
        /// modes are enabled by default.
        /// </para>
        /// </param>
        /// <returns>True if success; otherwise false.</returns>
        [DllImport(Kernel32, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, EntryPoint = "GetConsoleMode", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool GetConsoleMode(
            [In] SafeFileHandle consoleHandle,
            [Out, MarshalAs(UnmanagedType.U4)] out ConsoleMode consoleMode);

        /// <summary>
        /// Retrieves the file type of the specified file.
        /// </summary>
        /// <param name="fileHandle">A handle to the file.</param>
        /// <returns>A <see cref="FileType"/>.</returns>
        [DllImport(Kernel32, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, EntryPoint = "GetFileType", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.U4)]
        public static extern FileType GetFileType(
            [In, MarshalAs(UnmanagedType.SysInt)] IntPtr fileHandle);

        /// <summary>
        /// Retrieves a handle to the specified standard device (standard input, standard output, or
        /// standard error).
        /// </summary>
        /// <param name="std"></param>
        /// <returns>A Handle.</returns>
        [DllImport(Kernel32, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, EntryPoint = "GetStdHandle", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.SysInt)]
        public static extern IntPtr GetStdHandle(
            [In, MarshalAs(UnmanagedType.I4)] StandardHandleType std);

        /// <summary>
        /// Reads character input from the console input buffer and removes it from the buffer.
        /// </summary>
        /// <param name="consoleInputHandle">
        /// A handle to the console input buffer. The handle must have the
        /// <see cref="FileAccess.GenericRead"/> access right.
        /// </param>
        /// <param name="buffer">
        /// <para>A pointer to a buffer that receives the data read from the console input buffer.</para>
        /// <para>
        /// The storage for this buffer is allocated from a shared heap for the process that is 64 KB
        /// in size. The maximum size of the buffer will depend on heap usage.
        /// </para>
        /// </param>
        /// <param name="numberOfCharsToRead">
        /// The number of characters to be read. The size of the buffer pointed to by the
        /// <paramref name="buffer"/> parameter should be at least
        /// <paramref name="NumberofCharsToRead"/> * sizeof( <see cref="char"/>) bytes.
        /// </param>
        /// <param name="numberOfCharsRead">
        /// A pointer to a variable that receives the number of characters actually read.
        /// </param>
        /// <param name="reserved">Reserved; must be <see cref="IntPtr.Zero"/>.</param>
        /// <returns>True if success; otherwise false.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api")]
        [DllImport(Kernel32, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, EntryPoint = "ReadConsoleW", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool ReadConsole(
            [In] SafeFileHandle consoleInputHandle,
            [Out, MarshalAs(UnmanagedType.LPWStr)] StringBuilder buffer,
            [In, MarshalAs(UnmanagedType.U4)] uint numberOfCharsToRead,
            [Out, MarshalAs(UnmanagedType.U4)] out uint numberOfCharsRead,
            [In, MarshalAs(UnmanagedType.SysInt)] IntPtr reserved);

        /// <summary>
        /// Sets the input mode of a console's input buffer or the output mode of a console screen buffer.
        /// </summary>
        /// <param name="consoleHandle">
        /// A handle to the console input buffer or a console screen buffer. The handle must have the
        /// <see cref="FileAccess.GenericRead"/> access right.
        /// </param>
        /// <param name="consoleMode">
        /// <para>
        /// The input or output mode to be set. If the <paramref name="consoleHandle"/> parameter is
        /// an input handle, the mode can be one or more of the following values. When a console is
        /// created, all input modes except <see cref="ConsoleMode.WindowInput"/> are enabled by default.
        /// </para>
        /// <para>
        /// If the <paramref name="consoleHandle"/> parameter is a screen buffer handle, the mode can
        /// be one or more of the following values. When a screen buffer is created, both output
        /// modes are enabled by default.
        /// </para>
        /// </param>
        /// <returns>True if success; otherwise false.</returns>
        [DllImport(Kernel32, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, EntryPoint = "SetConsoleMode", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool SetConsoleMode(
            [In] SafeFileHandle consoleHandle,
            [In, MarshalAs(UnmanagedType.U4)] ConsoleMode consoleMode);

        /// <summary>
        /// Writes a character string to a console screen buffer beginning at the current cursor location.
        /// </summary>
        /// <param name="consoleOutputHandle">
        /// A handle to the console screen buffer. The handle must have the
        /// <see cref="FileAccess.GenericWrite"/> access right.
        /// </param>
        /// <param name="buffer">
        /// <para>
        /// A pointer to a buffer that contains characters to be written to the console screen buffer.
        /// </para>
        /// <para>
        /// The storage for this buffer is allocated from a shared heap for the process that is 64 KB
        /// in size. The maximum size of the buffer will depend on heap usage.
        /// </para>
        /// </param>
        /// <param name="numberOfCharsToWrite">
        /// The number of characters to be written. If the total size of the specified number of
        /// characters exceeds the available heap, the function fails with <see cref="Win32Error.NotEnoughMemory"/>.
        /// </param>
        /// <param name="numberOfCharsWritten">
        /// A pointer to a variable that receives the number of characters actually written.
        /// </param>
        /// <param name="reserved">Reserved; must be <see cref="IntPtr.Zero"/>.</param>
        /// <returns>True if success; otherwise false.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api")]
        [DllImport(Kernel32, CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, EntryPoint = "WriteConsoleW", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool WriteConsole(
            [In] SafeHandle consoleOutputHandle,
            [In, MarshalAs(UnmanagedType.LPWStr)] StringBuilder buffer,
            [In, MarshalAs(UnmanagedType.U4)] uint numberOfCharsToWrite,
            [Out, MarshalAs(UnmanagedType.U4)] out uint numberOfCharsWritten,
            [In, MarshalAs(UnmanagedType.SysInt)] IntPtr reserved);

        /// <summary>
        /// The System Error Codes are very broad. Each one can occur in one of many hundreds of
        /// locations in the system. Consequently the descriptions of these codes cannot be very
        /// specific. Use of these codes requires some amount of investigation and analysis. You need
        /// to note both the programmatic and the run-time context in which these errors occur.
        /// Because these codes are defined in WinError.h for anyone to use, sometimes the codes are
        /// returned by non-system software. Sometimes the code is returned by a function deep in the
        /// stack and far removed from your code that is handling the error.
        /// </summary>
        internal static class Win32Error
        {
            /// <summary>
            /// The operation completed successfully.
            /// </summary>
            public const int Success = 0;
            /// <summary>
            /// The system cannot find the file specified.
            /// </summary>
            public const int FileNotFound = 2;
            /// <summary>
            /// The handle is invalid.
            /// </summary>
            public const int InvalidHandle = 6;
            /// <summary>
            /// Not enough storage is available to process this command.
            /// </summary>
            public const int NotEnoughMemory = 8;
            /// <summary>
            /// A device attached to the system is not functioning.
            /// </summary>
            public const int GenericFailure = 31;
            /// <summary>
            /// The process cannot access the file because it is being used by another process.
            /// </summary>
            public const int SharingViolation = 32;
            /// <summary>
            /// The file exists.
            /// </summary>
            public const int FileExists = 80;
            /// <summary>
            /// The data area passed to a system call is too small.
            /// </summary>
            public const int InsufficientBuffer = 122;
            /// <summary>
            /// Cannot create a file when that file already exists.
            /// </summary>
            public const int AlreadExists = 183;
            /// <summary>
            /// The implementation is not capable of performing the request.
            /// </summary>
            public const int NotCapable = 775;
            /// <summary>
            /// Element not found.
            /// </summary>
            public const int NotFound = 1168;
            /// <summary>
            /// A specified logon session does not exist. It may already have been terminated.
            /// </summary>
            public const int NoSuchLogonSession = 1312;

            public static string GetText(int error)
            {
                switch (error)
                {
                    default:
                        return error.ToString();

                    case 1:
                        return "INVALID_FUNCTION";

                    case NativeMethods.Win32Error.AlreadExists:
                        return "ALREADY_EXISTS";

                    case NativeMethods.Win32Error.FileExists:
                        return "FILE_EXISTS";

                    case NativeMethods.Win32Error.FileNotFound:
                        return "FILE_NOT_FOUND";

                    case NativeMethods.Win32Error.GenericFailure:
                        return "GENERIC_FAILURE (" + error + ")";

                    case NativeMethods.Win32Error.InsufficientBuffer:
                        return "INSUFFICIENT_BUFFER";

                    case NativeMethods.Win32Error.InvalidHandle:
                        return "INVALID_HANDLE";

                    case NativeMethods.Win32Error.NoSuchLogonSession:
                        return "NO_SUCH_LOGON_SESSION";

                    case NativeMethods.Win32Error.NotCapable:
                        return "NOT_CAPABLE";

                    case NativeMethods.Win32Error.NotEnoughMemory:
                        return "NOT_ENOUGH_MEMORY";

                    case NativeMethods.Win32Error.NotFound:
                        return "NOT_FOUND";

                    case NativeMethods.Win32Error.SharingViolation:
                        return "SHARING_VILOATION";

                    case NativeMethods.Win32Error.Success:
                        return "SUCCESS";
                }
            }
        }
    }
}
